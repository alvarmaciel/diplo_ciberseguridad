#+title:      second-preimage
#+date:       [2025-11-12 mié 16:00]
#+filetags:   :cripto:diplomatura:famaf:
#+identifier: 20251112T160028

* Ejercicio second pre image

** Enunciado
El desafío consiste en encontrar una segunda preimagen al resultado de aplicar una función de hash de 24 bits a su dirección de correo electrónico.

Usaremos una función que consiste en aplicar SHA-256 y tomar los primeros N bits del resultado. Llamaremos a esta función SHA-256-N.

Veamos un ejemplo. En todos los casos representaremos las salidas de las funciones de hash como cadenas hexadecimales:

SHA-256("user@example.com") = b4c9a289323b21a01c3e940f150eb...

Entonces

SHA-256-24("user@example.com") = b4c9a2
SHA-256-48("user@example.com") = b4c9a289323b

Cada byte (8 bits) está representado por 2 caracteres hexadecimales, por lo que SHA-256-24 tiene una salida de 6 caracteres, y SHA-256-48 una de 12.

Para obtener el hash se puede realizar un requerimiento GET a una URL de la forma:

https://ciberseguridad.diplomatura.unc.edu.ar/cripto/second-preimage/<email>/challenge

donde <email> debe ser reemplazado por una dirección de correo electrónico registrada.

De todas formas no es estrictamente necesario, ya que el mismo resultado puede obtenerse aplicando SHA-256 sobre la dirección de correo electrónico y tomando los primeros 24 bits.

Por ejemplo, para obtener SHA-256-24 en un shell:
#+begin_src bash
echo -n user@example.com | sha256sum | cut -c-6
#+end_src

#+RESULTS:
: b4c9a2

o python
#+begin_src python :results output
from hashlib import sha256
print(sha256(b'user@example.com').hexdigest()[:6])
#+end_src

#+RESULTS:
: b4c9a2



** Respuesta

La respuesta debe ser enviada mediante un requerimiento POST a la URL

https://ciberseguridad.diplomatura.unc.edu.ar/cripto/second-preimage/<email>/answer

El contenido debe ser de tipo FORM, con un campo message con un nuevo mensaje que produzca el mismo hash.
Ejemplo

El siguiente ejemplo muestra como conectarse con el servidor usando curl
#+begin_src bash :noeval
$ curl https://ciberseguridad.diplomatura.unc.edu.ar/cripto/second-preimage/user@example.com/challenge 
b4c9a2
$ curl -F message='user@example.comJ<]x' https://ciberseguridad.diplomatura.unc.edu.ar/cripto/second-preimage/user@example.com/answer
¡Ganaste!
$ echo -n 'user@example.comJ<]x'| sha256sum |cut -c-6
b4c9a2

#+end_src

*** Observaciones

- Para encontrar una preimagen, el esfuerzo necesario es del orden de \(2^{n}\)  donde \(n\) es la longitud del hash. En este caso \(n=24\), por lo que se requiere calcular unos pocos millones de hashes.
- El cálculo no debería tomar más de unas decenas de segundos en una computadora con un procesador reciente.
** Solución



#+begin_src python :results output :session cripto
from hashlib import sha256

target = b'alvarmaciel@gmail.com'
print(sha256(target).hexdigest()[:6])
expected = sha256(target).hexdigest()[:6]
message = b''
for i in range(0, (2**32)-1):
     test = target+i.to_bytes(4, 'big')
     if sha256(test).hexdigest()[:6] == expected:
         message = test    
         break
print(message)
print(sha256(message).hexdigest()[:6])
with open('message.bin', 'wb') as f:
    f.write(message)

#+end_src

#+RESULTS:
: 7ae248
: b'alvarmaciel@gmail.com\x00\x18\xf5b'
: 7ae248

#+begin_src python :results output :session cripto
import requests
url = 'https://ciberseguridad.diplomatura.unc.edu.ar/cripto/second-preimage/alvarmaciel@gmail.com/answer'
data = {'message': message}
print(message)
response = requests.post(url, files=data)
print(response.status_code)
print(response.text)
#+end_src

#+RESULTS:
: b'alvarmaciel@gmail.com\x00\x18\xf5b'
: 200
: ¡Ganaste!


** Reflexión
*** Concepto criptográfico
Realicé un ataque de segunda preimagen: generé un mensaje diferente a alvarmaciel@gmail.com que produce el mismo hash SHA-256-24. Fue rápido porque solo necesité probar ~2^24 = 16 millones de valores en promedio. Si usáramos 48 bits, serían 2^48 = (2^24)^2 valores, tardando meses en vez de 0.5 segundos. SHA-256 completo (256 bits) hace computacionalmente inviable este ataque con recursos actuales.

Ahora si usaramos el doble, 48 byts es 2^24 x 2^24 16M x 16M.
Si 24 bits tardaron 0.5 segundos en procesarlos, 48 tardaría varis meses. Dado que el hash256 tiene 256 bits hace muy difícil la creación de segundas preimagenes. Lo que no quiere decir que con una computadora cuantica nos e pueda hacer

- Segunda pre imagen :: Mensaje M1 y debo encontrar M2 distinto de M! tal que hash(M1) =  hash(M2)

*** Implementación técnica
Iteré un contador de 0 a 2^32, convirtiendo cada número a 4 bytes con .to_bytes(4, 'big') y concatenándolo al email. Esto fue más simple que usar 4 loops anidados. El algoritmo paró cuando hash(mensaje_candidato)[:6] == '7ae248'.

*** Lección práctica

Esto nos demuestra que nunca tenemos que usar hashes truncados como SHA-256-24 en producción la Longitud mínima recomendada para seguridad real es SHA-256 -> 64 char hexa -> 32 bytes -> 256 bits


* Ejercicio colisión
** Enunciado
En este caso el servidor no provee ningún desafío, sino que es necesario generar dos mensajes distintos que colisionen utilizando SHA-256-48. El contenido y longitud de ambos mensajes es arbitrario, pero ambos deben incluir la dirección de correo electrónico registrada.
** Respuesta
La respuesta debe ser enviada mediante un requerimiento POST a la URL

https://ciberseguridad.diplomatura.unc.edu.ar/cripto/collision/<email>/answer

El contenido debe ser de tipo FORM, con dos campos message1 y message2 que deberán contener los mensajes que colisionan.
#+begin_src bash :noeval
curl -F message1='user@example.comJ<]x' -F message2='user@example.com!!%&/!' https://ciberseguridad.diplomatura.unc.edu.ar/cripto/collision/user@example.com/answer
¡Ganaste!
echo -n 'user@example.comJ<]x'| sha256sum | cut -c-12
c16170259226
echo -n 'user@example.com;$sN'| sha256sum | cut -c-12
c16170259226

#+end_src
Para encontrar una colisión, el esfuerzo necesario es del orden de , donde es la longitud del hash. En este caso
= 48, por lo que se requiere calcular unos pocos millones de hashes.
El cálculo no debería tomar más de unas decenas de segundos en una computadora con un procesador reciente.
** Solución
#+begin_src python :results output :session collision
from hashlib import sha256
email = b"alvarmaciel@gmail.com"
checked = {}
messages = []
for i in range(2**25):
    message = email + i.to_bytes(4, 'big')
    hash_48 = sha256(message).hexdigest()[:12]
    if hash_48 in checked:
        messages = [checked.get(hash_48), message]
        break
    else:
        checked[hash_48]= message
print(f"Iteraciones completadas: {i}")
print(f"Hashes únicos guardados: {len(checked)}")
print(f"¿Se encontró colisión?: {len(messages) > 0}")
m1, m2 = messages
h1 = sha256(m1).hexdigest()[:12]
h2 = sha256(m2).hexdigest()[:12]
print(f"M1: {m1}")
print(f"M2: {m2}")
print(f"Hash M1: {h1}")
print(f"Hash M2: {h2}")
print(f"¿Son iguales?: {h1 == h2}")
print(f"¿Mensajes diferentes?: {m1 != m2}")
#+end_src

#+RESULTS:
: Iteraciones completadas: 8992364
: Hashes únicos guardados: 8992364
: ¿Se encontró colisión?: True
: M1: b'alvarmaciel@gmail.com\x00^\xc7\xfb'
: M2: b'alvarmaciel@gmail.com\x00\x896l'
: Hash M1: ec8221e55a2c
: Hash M2: ec8221e55a2c
: ¿Son iguales?: True
: ¿Mensajes diferentes?: True

#+begin_src python :results output :session collision
import requests
url = 'https://ciberseguridad.diplomatura.unc.edu.ar/cripto/collision/alvarmaciel@gmail.com/answer'
data = {'message1': m1, 'message2':m2}
print(data)
response = requests.post(url, files=data)
print(response.status_code)
print(response.text)
#+end_src

#+RESULTS:
: {'message1': b'alvarmaciel@gmail.com\x00^\xc7\xfb', 'message2': b'alvarmaciel@gmail.com\x00\x896l'}
: 200
: ¡Ganaste!

** Reflexión
